
This project is to unit test repository class logic with in-memory database
Reference [link] https://www.baeldung.com/spring-jpa-test-in-memory-database

This code uses following concepts during configuration of this project:

#@PropertySource 			
	used to extrenalize your configurations from properties via 2 different ways of using @value or Environment variable of spring
	We have used Environment variable strategy here
					
#@EnableJpaRepositories	
	It will scan mentioned packages to find repositories which will use loaded dataSource
	
#What kind of Beans are required to have in-memory database enabled?
	1) ##DataSource Bean
		- creates a datasource bean instance which fetch database configurations from properties file
	2) ##EntityManagerFactory Bean
		- required to have an entityManager instance during creation of Employee repository. 
		- If not added then Repository instance will not be created as we it's depencency of entityManager will not get resolved.
	3) ##PlatformTransactionManager Bean
		- required to have transactionManager bean for CRUD operations on JPA repository; 
		- If datasource is defined via jdbc and by manually loading datasource then creation of transaction manager bean is required.
		- If datasource is defined via spring and by datasource is loaded by spring automatically then creation of transaction manager bean is handled by spring.
		
#What kind of additonal properties are set in EntityManagerFactory?
	1) ##hibernate.hbm2ddl.auto
		- to tell what kind of strategy to use for entities management i.e create, update
	2) ##hibernate.dialect
		- to tell concrete Dialect( database) to be used with hibernate. i.e Postgres,MySQL, Oracle etc
	3) ##hibernate.show_sql
		- to tell that show all queries generated by hibernate
	4) ##hibernate.cache.use_second_level_cache (optional)
		- set 2nd level caching strategy.
		As hibernate provides caching facility to improve quering process by fetching data direct from cache instead of database.
			1. first-level cache
				a. Session Scoped cache which allows creation of entity instance just *once* in **persistent context**
				b. Created when a session started and terminated as soon as session is closed.
				c. Desirable when multiple sessions need to have access to same entity instance.
			2. second level cache
				a. Session Factory scoped cache which allows creation of entity instance just *once* in **persistent context**  
				b. Accessible by all sessions created by sessionFactory.
				c. When an entity is access via id by any session or by hibernate (internally), it's first looked into 1st level cache and if found then return;
					otherwise it's found in 2nd level cache and if found then return otherwise it's found in database.
	5) ##hibernate.cache.use_query_cache	(optional)
		- to tell if query needs to be cached in hibernate

#src/java/resources/application.properties OR src/test/resources/application.properties
	- we can use spring or jdbc for database connection
	- test properties will override src properties for the testcases

#What annotations we have used in Unit Test class?
	1) @RunWith(SpringJUnit4Runner.class)
		- Tells to use spring JUnit4 supported functionalities in test class
		- We can also use @RunWith(SpringRunner.class) which will also load application context for Dependency Injection
		
	2) @ContextConfiguration
		- tells which configuration classes are required to load application context which is needed to inject dependecies (e.g EmployeeRepository)


		





